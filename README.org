#+title: Tomosipo
#+hugo_base_dir: ./doc/
[[file:./doc/img/logo.svg]]

* Tomosipo
Tomosipo is a pythonic wrapper for the ASTRA-toolbox of high-performance GPU
primitives for 3D tomography.

The aim of this library is as to:
- Expose a user-friendly API for high-performance 3D tomography, while
  allowing strict control over resource usage
- Enable easy manipulation of 3D geometries
- Provide easy integration with
  - Deep learning toolkits, such as [[https://pytorch.org][PyTorch]]
  - [[https://github.com/odlgroup/odl][The operator discretization library (ODL)]] for optimization in
    inverse problems
  - [[http://pyqtgraph.org/][PyQtGraph]] for interactive visualization of geometries and data

| Latest version: | https://anaconda.org/aahendriksen/tomosipo/badges/version.svg                      |
| Last updated:   | https://anaconda.org/aahendriksen/tomosipo/badges/latest_release_relative_date.svg |
| Documentation:  | https://aahendriksen.gitlab.io/tomosipo/index.html                                 |
* Installation
A minimal installation requires:
- python >= 3.6
- ASTRA-toolbox (the latest 1.9.x development version is *required*)
- CUDA

These requirements can be installed using conda (replace =<X.X>= by your
CUDA version)
#+BEGIN_SRC sh
conda create -y -n tomosipo python=3.8 astra-toolbox cudatoolkit=<X.X> -c astra-toolbox/label/dev
pip install git+https://github.com/ahendriksen/tomosipo@develop
source activate tomosipo
#+END_SRC

To use tomosipo with PyTorch, QT, ODL, and cupy, install:
#+BEGIN_SRC sh
  conda create -y -n tomosipo python=3.8 astra-toolbox cudatoolkit=<X.X> pytorch cupy pyqtgraph pyqt pyopengl cupy \
        -c defaults -c astra-toolbox/label/dev -c pytorch -c conda-forge
  source activate tomosipo
  # Install latest version of ODL:
  pip install git+https://github.com/odlgroup/odl
  # Install development version of tomosipo:
  pip install git+https://github.com/ahendriksen/tomosipo@develop
#+END_SRC

* Usage
Simple examples:
** Create and visualize geometries
#+BEGIN_SRC python :results output
  import astra
  import numpy as np
  import tomosipo as ts
  from tomosipo.qt import display

  # Create 'unit' cone geometry
  pg = ts.cone(angles=100, size=np.sqrt(2), cone_angle=0.5)
  print(pg)

  # Create volume geometry of a unit cube on the origin
  vg = ts.volume()
  print(vg)

  # Display an animation of the acquisition geometry
  display(pg, vg)
#+END_SRC

#+RESULTS:
#+begin_example
ConeGeometry(
    angles=100,
    shape=(1, 1),
    size=(1.4142135623730951, 1.4142135623730951),
    src_orig_dist=4.242640687119286,
    src_det_dist=4.242640687119286
)
VolumeGeometry(
    shape=(1, 1, 1),
    pos=(0.0, 0.0, 0.0),
    size=(1.0, 1.0, 1.0),
)
#+end_example


** Express algorithms succinctly

In the following example, we implement the simultaneous iterative
reconstruction algorithm (SIRT) in a couple of lines. This examples
demonstrates the use of the forward and backward projection.

First, the SIRT algorithm is implemented using numpy arrays, which
reside in system RAM. Then, we move all data onto the GPU, and compute
the same algorithm using PyTorch. This is faster, because no transfers
between system RAM and GPU are necessary.

#+begin_src python :results output
  import astra
  import numpy as np
  import tomosipo as ts
  from timeit import default_timer as timer

  # Create 'unit' cone geometry, and a
  pg = ts.cone(size=np.sqrt(2), cone_angle=1/2, angles=100, shape=(128, 192))
  # Create volume geometry of a unit cube on the origin
  vg = ts.volume(shape=128)
  # Create projection operator
  A = ts.operator(vg, pg)

  # Create a phantom containing a small cube:
  phantom = np.zeros(A.domain_shape)
  phantom[20:50, 20:50, 20:50] = 1.0

  # Prepare preconditioning matrices R and C
  R = 1 / A(np.ones(A.domain_shape))
  R = np.minimum(R, 1 / ts.epsilon)
  C = 1 / A.T(np.ones(A.range_shape))
  C = np.minimum(C, 1 / ts.epsilon)

  # Reconstruct from sinogram y into x_rec in 100 iterations
  y = A(phantom)
  x_rec = np.zeros(A.domain_shape)
  num_iters = 100

  start = timer()
  for i in range(num_iters):
      x_rec += C * A.T(R * (y - A(x_rec)))
  print(f"SIRT finished in {timer() - start:0.2f} seconds")

  # Perform the same computation on the GPU using PyTorch.
  # First, import support for pytorch tensors
  import tomosipo.torch_support

  # Move all data to GPU:
  dev = torch.device("cuda")
  y = torch.from_numpy(y).to(dev)
  R = torch.from_numpy(R).to(dev)
  C = torch.from_numpy(C).to(dev)
  x_rec = torch.zeros(A.domain_shape, device=dev)

  # Perform algorithm
  start = timer()
  for i in range(num_iters):
      x_rec += C * A.T(R * (y - A(x_rec)))

  # Convert reconstruction back to numpy array:
  x_rec = x_rec.cpu().numpy()
  print(f"SIRT finished in {timer() - start:0.2f} seconds using PyTorch")
#+end_src

#+begin_example
SIRT finished in 2.07 seconds
SIRT finished in 0.94 seconds using PyTorch
#+end_example
** More examples
Please checkout the =examples= and =notebooks= directory for more examples.

* Authors and contributors
tomosipo is developed by the Computational Imaging group at CWI. Original author:

- *Allard Hendriksen*

We thank the following authors for their contribution

- *Johannes Leuschner* - ODL integration

See also the list of contributors who participated in this project.

